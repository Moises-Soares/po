@startuml
title MVC Architecture - SpotifUM with Model Layer, Storage Strategy, and View Screen Pattern

package "App" {
    class SpotifumApp {
        + main(args: String[]): void
    }
}

package "View" {
    interface ViewScreen {
        + run(): void
    }

    class SpotifumView {
        - controller: SpotifumController
        - currentScreen: ViewScreen

        + SpotifumView(controller: SpotifumController)
        + run(): void
        + setScreen(screen: ViewScreen): void
    }

    class MainMenuScreen implements ViewScreen
    class CreateUserScreen implements ViewScreen
    class CreateAlbumScreen implements ViewScreen
    class CreatePlaylistScreen implements ViewScreen
    class PlaySongScreen implements ViewScreen
    class ListUsersScreen implements ViewScreen
}

package "Controller" {
    class SpotifumController {

        - model: SpotifumModel

        + SpotifumController(model: SpotifumModel)

        + addUser(name: String, email: String, planName: String): void
        + listAllUsers(): List<User>
        + getUserByEmail(email: String): User
        + searchUserByName(name: String): List<User>

        + addAlbum(name: String, artist: String): void
        + listAllAlbums(): List<Album>
        + getAlbumByName(name: String): Album
        + searchAlbumByName(name: String): List<Album>

        + createRandomPlaylistForUSer(user: User, name: String, size: int): void
        + createOrderedPlaylistForUser(user: User, name: String, songs: List<Song>): void

    }
}

package "Model" {

    ' Represents the main model of the application
    ' It contains the data and the logic to manipulate it
    class SpotifumModel {

        - storageStrategy: StorageStrategy
        - songPlayer: SongPlayer
        - users: List<User>
        - albums: List<Album>
        - publicPlaylists: List<Playlist>
        - subscriptionPlans: List<SubscriptionPlan>

        + SpotifumModel(storageStrategy: StorageStrategy)

        + setStorageStrategy(storageStrategy: StorageStrategy): void
        + loadData(): void
        + saveData(): void

        + addUser(u: User): void
        + getUsers(): List<User>
        + getUserByEmail(email: String): User

        + addAlbum(a: Album): void
        + getAlbums(): List<Album>
        + getAlbumByName(name: String): Album

        + addPublicPlaylist(p: Playlist): void
        + getPublicPlaylists(): List<Playlist>

        + addSubscriptionPlan(p: SubscriptionPlan): void
        + getSubscriptionPlans(): List<SubscriptionPlan>
        + getSubscriptionPlanByName(name: String): SubscriptionPlan
    }


    ' Abstract class for storage strategies
    abstract class StorageStrategy {
        + loadData(): void
        + saveData(): void
    }

    ' This strategy is used when the data is stored in a single file
    class SingleFileStorageStrategy extends StorageStrategy {
        + loadData(): void
        + saveData(): void
    }

    ' This strategy is used when the data is stored in multiple files
    class MultipleFileStorageStrategy extends StorageStrategy {
        + loadData(): void
        + saveData(): void
    }

    class Album {
            - name: String
            - artist: String
            - releaseDate: Date
            - songs: List<Song>

            + addSong(song: Song): void
            + getSongs(): List<Song>
    }


    interface Streamable {
        + getStream(): String
    }

    class Song implements Streamable {
        - name: String
        - artist: String
        - publisher: String
        - lyrics: String
        - music: List<String>
        - genre: String
        - duration: int
        - playCount: int

        + incrementPlayCount(): void
        + getStream(): String
    }

    
    abstract class SongDecorator implements Streamable {
        - decoratedSong: Streamable
        + SongDecorator(decoratedSong: Streamable)
        + getStream(): String
    }

    class ExplicitSongDecorator extends SongDecorator {
        + ExplicitSongDecorator(song: Streamable)
        + getStream(): String
    }

    class MultimediaSongDecorator extends SongDecorator {
        + MultimediaSongDecorator(song: Streamable)
        + getStream(): String
    }

    
' Interface comum para Playlists
abstract class  Playlist {
    # getSongs(): List<Song>
    + play(): void
    + hasNext(): boolean
    + hasPrevious(): boolean
    + next(): Song
    + previous(): Song
    + shuffle(): void
}

class RandomPlaylist extends Playlist {
    + addRandom(albums: List<Album>, size: int): void
}

class OrderedPlaylist extends Playlist {
    - isShuffle: boolean
}

class FavoritePlaylist extends Playlist {
    + generate(user: User): void
}

class TimeLimitedPlaylist extends Playlist {
    - maxDuration: int
    + generate(albums: List<Album>, maxDuration: int): void
}


 ' Interface para tipos de planos
abstract class SubscriptionPlan {
    + getName(): String
    + canCreatePlaylist(): boolean
    + canAccessFavorites(): boolean
    + canPlaySpecificSong(): boolean
    + getMaxRandomPlaylists(): int
    + getMaxNonRandomPlaylists(): int
    + getPointsPerSong(currentPoints: double): double
}

' Plano Free
class FreePlan extends SubscriptionPlan {
    + getName(): String
    + canCreatePlaylist(): boolean
    + canAccessFavorites(): boolean
    + canPlaySpecificSong(): boolean
    + getMaxRandomPlaylists(): int
    + getMaxNonRandomPlaylists(): int
    + getPointsPerSong(currentPoints: double): double
}

' Plano Premium Base
class PremiumBasePlan extends SubscriptionPlan {
    + getName(): String
    + canCreatePlaylist(): boolean
    + canAccessFavorites(): boolean
    + canPlaySpecificSong(): boolean
    + getMaxRandomPlaylists(): int
    + getMaxNonRandomPlaylists(): int
    + getPointsPerSong(currentPoints: double): double
}

' Plano Premium Top (extende o Base)
class PremiumTopPlan extends PremiumBasePlan {
    + canAccessFavorites(): boolean
    + getMaxRandomPlaylists(): int
    + getMaxNonRandomPlaylists(): int
    + getPointsPerSong(currentPoints: double): double
}



    abstract class SongPlayer {
        - currentSong: Song
        + play(song: Song): void
        + pause(): void
        + stop(): void
    }

    class TextPlayer extends SongPlayer {
        + play(song: Song): void
        + pause(): void
        + stop(): void
    }

 



  ' Represents a user of the system
    class User {
        - name: String
        - email: String
        - address: String
        - points: double
        - subscription: SubscriptionPlan

        - library: List<Album>
        - playlists: List<Playlist>
        - songPlayCount: Map<Song, Integer>

        + createRandomPlaylist(name: String, size: int): Playlist
        + createOrderedPlaylist(name: String, songs: List<Song>): Playlist

        
    }

   

   



    

    
}

' RELATIONSHIPS
SpotifumApp --> SpotifumView : runs
SpotifumView --> SpotifumController : uses
SpotifumView --> ViewScreen :  sets screen
SpotifumController --> SpotifumModel : manages
SpotifumModel --> StorageStrategy : delegates storage logic to
SpotifumModel --> User : stores
SpotifumModel --> Album : stores
SpotifumModel --> SubscriptionPlan : stores
SpotifumModel --> Playlist : stores
Album *-- Song
SongPlayer o-- Song : currentSong 
SongDecorator --> Streamable : decorates
User --> Song : play count history

@enduml
